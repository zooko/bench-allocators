# Allocator Performance Benchmarks

**generated:** 2026-01-21 04:06:30 UTC
**git commit:** 6e7576c0be49eb648631323ef04d68ab94a3db93
**git clean status:** Uncommitted changes
**CPU:** Apple M4 Max
**OS:** darwin25

This report compares memory allocator performance in different codebases.

Allocators:

* default: the default Rust global allocator, which in current Rust falls through to the system
  allocator
* [jemalloc](https://github.com/jemalloc/jemalloc): using [tikv-jemallocator](https://github.com/tikv/jemallocator) Rust wrappers
* [snmalloc](https://github.com/microsoft/snmalloc): using [snmalloc-rs](https://github.com/SchrodingerZhu/snmalloc-rs) Rust wrappers
* [mimalloc](https://github.com/microsoft/mimalloc): using [mimalloc_rust](https://github.com/purpleprotocol/mimalloc_rust) Rust wrappers
* [rpmalloc](https://github.com/mjansson/rpmalloc): using [rpmalloc-rs](https://github.com/EmbarkStudios/rpmalloc-rs) Rust wrappers
* [smalloc](https://github.com/zooko/smalloc): (written in Rust)

Work-loads:

* [**simd-json](https://github.com/simd-lite/simd-json)**: High-performance JSON parser ([fork for benchmarking](https://github.com/zooko/simd-json))
- [**rebar](https://github.com/BurntSushi/rebar)**: Regex engine benchmark harness ([fork for benchmarking](https://github.com/zooko/simd-json))

---

## simd-json Results

### Performance Graph

![simd-json allocator performance](simd-json.graph.svg)

### Detailed Results

[View detailed simd-json results](simd-json.result.txt)

---

## rebar Results

### Performance Graph

![rebar allocator performance](rebar.graph.svg)

### Detailed Results

[View detailed rebar results](rebar.result.txt)

---

## Summary

Both benchmarks show allocator performance impact on real-world Rust applications:

- **simd-json** tests memory allocation patterns in JSON parsing workloads
- **rebar** tests memory allocation patterns in regex compilation and matching

### Key Findings

Compare the graphs above to see:
1. Which allocators consistently perform well across different workload types
2. Whether certain allocators excel at specific types of memory usage patterns
3. The magnitude of performance differences (typically 1-10% range)

### Methodology

- Each allocator is tested using identical code with only the global allocator changed
- Benchmarks calculate geometric mean of normalized performance ratios across all tests
- Results show percentage differences from baseline (system allocator)
- Lower percentages = better performance (less overhead)

### How to Read the Graphs

- **Baseline (default)**: The system allocator, shown at 100%
- **Negative percentages**: Faster than baseline (e.g., -3% means 3% faster)
- **Positive percentages**: Slower than baseline (e.g., +5% means 5% slower)
- **Bar height**: Directly proportional to execution time

---

*Generated by run-all-benchmarks.sh*
*Source: https://github.com/zooko/rebar and https://github.com/zooko/simd-json*
